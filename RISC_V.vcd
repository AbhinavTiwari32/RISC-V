$date
	Thu Jul 31 20:29:55 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # zero_top $end
$var wire 1 $ sel2_top $end
$var wire 32 % mux1_top [31:0] $end
$var wire 32 & instruction_Top [31:0] $end
$var wire 4 ' control_top [3:0] $end
$var wire 1 ( branch_top $end
$var wire 32 ) address_top [31:0] $end
$var wire 32 * WriteBack_top [31:0] $end
$var wire 32 + Sum_out_top [31:0] $end
$var wire 1 , RegWrite_top $end
$var wire 32 - Rd2_top [31:0] $end
$var wire 32 . Rd1_top [31:0] $end
$var wire 32 / PCin_top [31:0] $end
$var wire 32 0 PC_top [31:0] $end
$var wire 32 1 NextoPc_top [31:0] $end
$var wire 1 2 MemtoReg_top $end
$var wire 32 3 Memdata_top [31:0] $end
$var wire 1 4 MemWrite_top $end
$var wire 1 5 MemRead_top $end
$var wire 32 6 ImmExt_top [31:0] $end
$var wire 1 7 ALUSrc_top $end
$var wire 2 8 ALUOpTop [1:0] $end
$scope module ALU_Control $end
$var wire 3 9 fun3 [2:0] $end
$var wire 1 : fun7 $end
$var wire 2 ; ALUOp [1:0] $end
$var reg 4 < Control_out [3:0] $end
$upscope $end
$scope module ALU_mux $end
$var wire 1 7 sel1 $end
$var wire 32 = Mux1_out [31:0] $end
$var wire 32 > B1 [31:0] $end
$var wire 32 ? A1 [31:0] $end
$upscope $end
$scope module ALU_unit $end
$var wire 32 @ B [31:0] $end
$var wire 4 A Control_in [3:0] $end
$var wire 32 B A [31:0] $end
$var reg 32 C ALU_Result [31:0] $end
$var reg 1 # zero $end
$upscope $end
$scope module AND $end
$var wire 1 $ and_out $end
$var wire 1 # zero $end
$var wire 1 ( branch $end
$upscope $end
$scope module Adder $end
$var wire 32 D in_2 [31:0] $end
$var wire 32 E in_1 [31:0] $end
$var wire 32 F Sum_out [31:0] $end
$upscope $end
$scope module Adder_mux $end
$var wire 32 G B2 [31:0] $end
$var wire 1 $ sel2 $end
$var wire 32 H Mux2_out [31:0] $end
$var wire 32 I A2 [31:0] $end
$upscope $end
$scope module Control_Unit $end
$var wire 7 J instruction [6:0] $end
$var reg 2 K ALUOp [1:0] $end
$var reg 1 7 ALUSrc $end
$var reg 1 ( Branch $end
$var reg 1 5 MemRead $end
$var reg 1 4 MemWrite $end
$var reg 1 2 MemtoReg $end
$var reg 1 , RegWrite $end
$upscope $end
$scope module Data_Memory $end
$var wire 1 5 MemRead $end
$var wire 1 4 MemWrite $end
$var wire 1 ! clk $end
$var wire 32 L read_address [31:0] $end
$var wire 1 " reset $end
$var wire 32 M Write_data [31:0] $end
$var wire 32 N MemData_out [31:0] $end
$var integer 32 O k [31:0] $end
$upscope $end
$scope module ImmGen $end
$var wire 7 P Opcode [6:0] $end
$var wire 32 Q instruction [31:0] $end
$var reg 32 R ImmExt [31:0] $end
$upscope $end
$scope module Inst_Memory $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 S read_address [31:0] $end
$var wire 32 T instruction_out [31:0] $end
$upscope $end
$scope module Memory_mux $end
$var wire 32 U A3 [31:0] $end
$var wire 32 V B3 [31:0] $end
$var wire 1 2 sel3 $end
$var wire 32 W Mux3_out [31:0] $end
$upscope $end
$scope module PC_Adder $end
$var wire 32 X fromPC [31:0] $end
$var wire 32 Y NextoPC [31:0] $end
$upscope $end
$scope module Program_Counter $end
$var wire 32 Z PC_in [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 [ PC_out [31:0] $end
$upscope $end
$scope module Register_File $end
$var wire 5 \ Rd [4:0] $end
$var wire 1 , RegWrite $end
$var wire 5 ] Rs1 [4:0] $end
$var wire 5 ^ Rs2 [4:0] $end
$var wire 32 _ Write_data [31:0] $end
$var wire 1 ! clk $end
$var wire 32 ` read_data1 [31:0] $end
$var wire 32 a read_data2 [31:0] $end
$var wire 1 " reset $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b100 Z
b100 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b1000000 O
b0 N
b0 M
b0 L
b0 K
b0 J
b100 I
b100 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b1111 A
b0 @
b0 ?
b0 >
b0 =
b1111 <
b0 ;
0:
b0 9
b0 8
07
b0 6
05
04
b0 3
02
b100 1
b0 0
b100 /
b0 .
b0 -
0,
b0 +
b0 *
b0 )
0(
b1111 '
b0 &
b0 %
0$
1#
1"
0!
$end
#5000
b1000000 O
1!
#10000
0#
b111001 *
b111001 W
b111001 _
b111001 )
b111001 C
b111001 L
b111001 U
b1100 +
b1100 F
b1100 G
b1100 6
b1100 >
b1100 D
b1100 R
17
14
b10 '
b10 <
b10 A
b1100 %
b1100 =
b1100 @
b100011 J
b10 9
b100011 P
b1100 \
b110111 -
b110111 ?
b110111 M
b110111 a
b1111 ^
b101101 .
b101101 B
b101101 `
b101 ]
b111100101010011000100011 &
b111100101010011000100011 Q
b111100101010011000100011 T
0!
0"
#15000
bx *
bx W
bx _
bx )
bx C
bx L
bx U
b0 6
b0 >
b0 D
b0 R
bx %
bx =
bx @
07
04
bx J
bx 9
x:
bx P
bx \
bx -
bx ?
bx M
bx a
bx ^
bx .
bx B
bx `
bx ]
bx &
bx Q
bx T
b1000 /
b1000 H
b1000 Z
b1000 1
b1000 I
b1000 Y
b100 +
b100 F
b100 G
b100 0
b100 E
b100 S
b100 X
b100 [
1!
#20000
0!
#25000
b1100 /
b1100 H
b1100 Z
b1100 1
b1100 I
b1100 Y
b1000 +
b1000 F
b1000 G
b1000 0
b1000 E
b1000 S
b1000 X
b1000 [
1!
#30000
0!
#35000
b10000 /
b10000 H
b10000 Z
b10000 1
b10000 I
b10000 Y
b1100 +
b1100 F
b1100 G
b1100 0
b1100 E
b1100 S
b1100 X
b1100 [
1!
#40000
0!
#45000
b10100 /
b10100 H
b10100 Z
b10100 1
b10100 I
b10100 Y
b10000 +
b10000 F
b10000 G
b10000 0
b10000 E
b10000 S
b10000 X
b10000 [
1!
#50000
0!
#55000
b11000 /
b11000 H
b11000 Z
b11000 1
b11000 I
b11000 Y
b10100 +
b10100 F
b10100 G
b10100 0
b10100 E
b10100 S
b10100 X
b10100 [
1!
#60000
0!
#65000
b11100 /
b11100 H
b11100 Z
b11100 1
b11100 I
b11100 Y
b11000 +
b11000 F
b11000 G
b11000 0
b11000 E
b11000 S
b11000 X
b11000 [
1!
#70000
0!
#75000
b100000 /
b100000 H
b100000 Z
b100000 1
b100000 I
b100000 Y
b11100 +
b11100 F
b11100 G
b11100 0
b11100 E
b11100 S
b11100 X
b11100 [
1!
#80000
0!
#85000
b100100 /
b100100 H
b100100 Z
b100100 1
b100100 I
b100100 Y
b100000 +
b100000 F
b100000 G
b100000 0
b100000 E
b100000 S
b100000 X
b100000 [
1!
#90000
0!
#95000
b101000 /
b101000 H
b101000 Z
b101000 1
b101000 I
b101000 Y
b100100 +
b100100 F
b100100 G
b100100 0
b100100 E
b100100 S
b100100 X
b100100 [
1!
#100000
0!
#105000
b101100 /
b101100 H
b101100 Z
b101100 1
b101100 I
b101100 Y
b101000 +
b101000 F
b101000 G
b101000 0
b101000 E
b101000 S
b101000 X
b101000 [
1!
#110000
0!
