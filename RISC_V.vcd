$date
	Sat Aug 16 13:21:10 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 32 # PCin_top [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 $ zero_top $end
$var wire 1 % sel2_top $end
$var wire 32 & mux1_top [31:0] $end
$var wire 32 ' instruction_Top [31:0] $end
$var wire 4 ( control_top [3:0] $end
$var wire 1 ) branch_top $end
$var wire 32 * address_top [31:0] $end
$var wire 32 + WriteBack_top [31:0] $end
$var wire 1 , RegWrite_top $end
$var wire 32 - Rd2_top [31:0] $end
$var wire 32 . Rd1_top [31:0] $end
$var wire 32 / PC_top [31:0] $end
$var wire 32 0 PCID_wire [31:0] $end
$var wire 32 1 NextoPc_top [31:0] $end
$var wire 1 2 MemtoReg_top $end
$var wire 32 3 Memdata_top [31:0] $end
$var wire 1 4 MemWrite_top $end
$var wire 1 5 MemRead_top $end
$var wire 32 6 Instruction_ID [31:0] $end
$var wire 32 7 ImmExt_top [31:0] $end
$var wire 1 8 EXfunc7_top $end
$var wire 3 9 EXfunc3_top [2:0] $end
$var wire 1 : EXbranch_top $end
$var wire 32 ; EXSum_out_top [31:0] $end
$var wire 1 < EXRegWrite_top $end
$var wire 5 = EXRd_top [4:0] $end
$var wire 32 > EXRd2_top [31:0] $end
$var wire 32 ? EXRd1_top [31:0] $end
$var wire 32 @ EXPC_top [31:0] $end
$var wire 1 A EXMemtoReg_top $end
$var wire 1 B EXMemWrite_top $end
$var wire 1 C EXMemRead_top $end
$var wire 32 D EXImmExt_top [31:0] $end
$var wire 1 E EXALUSrc_top $end
$var wire 2 F EXALUOpTop [1:0] $end
$var wire 1 G ALUSrc_top $end
$var wire 2 H ALUOpTop [1:0] $end
$scope module ALU_Control $end
$var wire 1 8 fun7 $end
$var wire 3 I fun3 [2:0] $end
$var wire 2 J ALUOp [1:0] $end
$var reg 4 K Control_out [3:0] $end
$upscope $end
$scope module ALU_mux $end
$var wire 1 E sel1 $end
$var wire 32 L Mux1_out [31:0] $end
$var wire 32 M B1 [31:0] $end
$var wire 32 N A1 [31:0] $end
$upscope $end
$scope module ALU_unit $end
$var wire 32 O B [31:0] $end
$var wire 4 P Control_in [3:0] $end
$var wire 32 Q A [31:0] $end
$var reg 32 R ALU_Result [31:0] $end
$var reg 1 $ zero $end
$upscope $end
$scope module AND $end
$var wire 1 % and_out $end
$var wire 1 $ zero $end
$var wire 1 ) branch $end
$upscope $end
$scope module Adder $end
$var wire 32 S in_2 [31:0] $end
$var wire 32 T in_1 [31:0] $end
$var wire 32 U Sum_out [31:0] $end
$upscope $end
$scope module Control_Unit $end
$var wire 7 V instruction [6:0] $end
$var reg 2 W ALUOp [1:0] $end
$var reg 1 G ALUSrc $end
$var reg 1 ) Branch $end
$var reg 1 5 MemRead $end
$var reg 1 4 MemWrite $end
$var reg 1 2 MemtoReg $end
$var reg 1 , RegWrite $end
$upscope $end
$scope module Data_Memory $end
$var wire 1 5 MemRead $end
$var wire 1 4 MemWrite $end
$var wire 1 ! clk $end
$var wire 32 X read_address [31:0] $end
$var wire 1 " reset $end
$var wire 32 Y Write_data [31:0] $end
$var wire 32 Z MemData_out [31:0] $end
$var integer 32 [ k [31:0] $end
$upscope $end
$scope module EXMEM_Reg $end
$var wire 32 \ EXADD_in [31:0] $end
$var wire 32 ] EXALURes_in [31:0] $end
$var wire 1 $ EXZero_in $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 < EXRegWrite_in $end
$var wire 5 ^ EXRd_in [4:0] $end
$var wire 32 _ EXRd2_in [31:0] $end
$var wire 1 A EXMemtoReg_in $end
$var wire 1 B EXMemWrite_in $end
$var wire 1 C EXMemRead_in $end
$var wire 1 : EXBranch_in $end
$var reg 32 ` MEMADD_out [31:0] $end
$var reg 32 a MEMALURes_out [31:0] $end
$var reg 1 b MEMBranch_out $end
$var reg 1 c MEMMemRead_out $end
$var reg 1 d MEMMemWrite_out $end
$var reg 1 e MEMMemtoReg_out $end
$var reg 32 f MEMRd2_out [31:0] $end
$var reg 5 g MEMRd_out [4:0] $end
$var reg 1 h MEMRegWrite_out $end
$var reg 1 i MEMZero_out $end
$upscope $end
$scope module IDEXE_Reg $end
$var wire 2 j IDALUOp_in [1:0] $end
$var wire 1 G IDALUSrc_in $end
$var wire 1 ) IDBranch_in $end
$var wire 1 5 IDMemRead_in $end
$var wire 1 4 IDMemWrite_in $end
$var wire 1 2 IDMemtoReg_in $end
$var wire 5 k IDRd_in [4:0] $end
$var wire 1 , IDRegWrite_in $end
$var wire 3 l IDfunc3_in [2:0] $end
$var wire 1 m IDfunc7_in $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 n IDRd2_in [31:0] $end
$var wire 32 o IDRd1_in [31:0] $end
$var wire 32 p IDPC_in [31:0] $end
$var wire 32 q IDImmGen_in [31:0] $end
$var reg 2 r EXEALUOp_out [1:0] $end
$var reg 1 E EXEALUSrc_out $end
$var reg 1 : EXEBranch_out $end
$var reg 32 s EXEImmGen_out [31:0] $end
$var reg 1 C EXEMemRead_out $end
$var reg 1 B EXEMemWrite_out $end
$var reg 1 A EXEMemtoReg_out $end
$var reg 32 t EXEPC_out [31:0] $end
$var reg 32 u EXERd1_out [31:0] $end
$var reg 32 v EXERd2_out [31:0] $end
$var reg 5 w EXERd_out [4:0] $end
$var reg 1 < EXERegWrite_out $end
$var reg 3 x EXEfunc3_out [2:0] $end
$var reg 1 8 EXEfunc7_out $end
$upscope $end
$scope module IFID_Reg $end
$var wire 32 y IFPCin [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 z IFProgMem_in [31:0] $end
$var reg 32 { IDPCout [31:0] $end
$var reg 32 | IDProgMem_out [31:0] $end
$upscope $end
$scope module ImmGen $end
$var wire 7 } Opcode [6:0] $end
$var wire 32 ~ instruction [31:0] $end
$var reg 32 !" ImmExt [31:0] $end
$upscope $end
$scope module Inst_Memory $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 "" read_address [31:0] $end
$var wire 32 #" instruction_out [31:0] $end
$upscope $end
$scope module Memory_mux $end
$var wire 32 $" A3 [31:0] $end
$var wire 32 %" B3 [31:0] $end
$var wire 1 2 sel3 $end
$var wire 32 &" Mux3_out [31:0] $end
$upscope $end
$scope module PC_Adder $end
$var wire 32 '" fromPC [31:0] $end
$var wire 32 (" NextoPC [31:0] $end
$upscope $end
$scope module Program_Counter $end
$var wire 32 )" PC_in [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 *" PC_out [31:0] $end
$upscope $end
$scope module Register_File $end
$var wire 5 +" Rd [4:0] $end
$var wire 1 , RegWrite $end
$var wire 5 ," Rs1 [4:0] $end
$var wire 5 -" Rs2 [4:0] $end
$var wire 32 ." Write_data [31:0] $end
$var wire 1 ! clk $end
$var wire 32 /" read_data1 [31:0] $end
$var wire 32 0" read_data2 [31:0] $end
$var wire 1 " reset $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 0"
b0 /"
b0 ."
b0 -"
b0 ,"
b0 +"
b0 *"
bz )"
b100 ("
b0 '"
b0 &"
b0 %"
b0 $"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b0 |
b0 {
b0 z
bz y
b0 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
b0 q
b0 p
b0 o
b0 n
0m
b0 l
b0 k
b0 j
0i
0h
b0 g
b0 f
0e
0d
0c
0b
b0 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b1000000 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b10 P
b0 O
b0 N
b0 M
b0 L
b10 K
b0 J
b0 I
b0 H
0G
b0 F
0E
b0 D
0C
0B
0A
b0 @
b0 ?
b0 >
b0 =
0<
b0 ;
0:
b0 9
08
b0 7
b0 6
05
04
b0 3
02
b100 1
b0 0
b0 /
b0 .
b0 -
0,
b0 +
b0 *
0)
b10 (
b0 '
b0 &
0%
x$
bz #
1"
0!
$end
#5000
b1000000 [
1!
#10000
b111100101010011000100011 '
b111100101010011000100011 z
b111100101010011000100011 #"
0!
0"
#15000
b1100 7
b1100 q
b1100 !"
bx '
bx z
bx #"
1G
14
b1100 k
b10 l
b100011 V
b100011 }
b1100 +"
b110111 -
b110111 Y
b110111 n
b110111 0"
b1111 -"
b101101 .
b101101 o
b101101 /"
b101 ,"
bx 1
bx ("
bz /
bz ""
bz '"
bz *"
b111100101010011000100011 6
b111100101010011000100011 |
b111100101010011000100011 ~
bz 0
bz p
bz {
xi
1!
#20000
0!
#25000
b111001 +
b111001 &"
b111001 ."
b111001 *
b111001 R
b111001 X
b111001 ]
b111001 $"
b0 7
b0 q
b0 !"
0G
04
b1100 &
b1100 L
b1100 O
1$
bx k
xm
bx l
bx V
bx }
bx +"
bx -
bx Y
bx n
bx 0"
bx -"
bx .
bx o
bx /"
bx ,"
b1100 =
b1100 ^
b1100 w
b10 9
b10 I
b10 x
b1100 D
b1100 M
b1100 S
b1100 s
b110111 >
b110111 N
b110111 _
b110111 v
b101101 ?
b101101 Q
b101101 u
bx ;
bx U
bx \
bz @
bz T
bz t
1B
1E
bx 6
bx |
bx ~
1!
#30000
0!
#35000
bx +
bx &"
bx ."
bx *
bx R
bx X
bx ]
bx $"
bx &
bx L
bx O
0$
bx =
bx ^
bx w
x8
bx 9
bx I
bx x
b0 D
b0 M
b0 S
b0 s
bx >
bx N
bx _
bx v
bx ?
bx Q
bx u
0B
0E
1i
b1100 g
b110111 f
b111001 a
bx `
1d
1!
#40000
0!
#45000
0i
bx g
bx f
bx a
0d
1!
#50000
0!
#55000
1!
#60000
0!
#65000
1!
#70000
0!
#75000
1!
#80000
0!
#85000
1!
#90000
0!
#95000
1!
#100000
0!
#105000
1!
#110000
0!
